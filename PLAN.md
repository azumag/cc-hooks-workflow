# Hooks Workflow ツール
Claude Code の Hooks で workflow をを構築するためツール

# 仕組み
`docs/principal.md` に記載

# 構成
## workflow
Claude Code からの Stop Hooks の起点スクリプト
ここで全ての状態を管理し、各 hooks スクリプトを呼び出す。

### ファイルベース状態管理
それぞれの hooks スクリプトで Claude Code から単一で出力される **状態フレーズ** をステートとして扱う。
トランスクリプトファイルから会話ログを取得し、最新の会話が状態フレーズであれば、現在そのステートであると判断する。
ステートからのアクションは単一で、呼び出しのみである。この `workflow` が呼び出されたとき、現在のステートから、呼び出す hooks スクリプトを決定する。
呼び出すフックスクリプトは、`状態フレーズ: スクリプト名` の形でマッピングを持つ。
また、何もない状態から最初に呼び出すスクリプトも同じマッピング、たとえば　`NONE: script.sh` の様な形で記述できる様にする。

### 作業報告の一時保存
状態フレーズが何もない状態で stop hook として呼び出されたということは、直前の会話ログは作業報告である。
これらを review タスクなどに渡したいので、/tmp/work_summary.log など一時的なファイルに保存し、のちのワークフローにパスを渡して参照できる様にする。プロセス間で衝突が起こらないように、ファイル名には適切な suffix をつけるべきだ。

### hooks スクリプトの呼び出し
`workflow` から状態フレーズに応じた適切な hooks スクリプトを呼び出す。 ./hooks 配下に配置される。
呼び出すときに作業報告ファイルのパスを受け取り、処理を行う。
claude へ処理を頼むとき、以下の形式の json を output する。
```
{
  "decision": "approve" | "block",
  "reason": "string"
}
```
基本的に、claudeに何かさせたいときは decision を block にし、reasonに指示内容を入れる。
処理終了時、この指示内容に固有の状態フレーズを単に表示すること、という指示を入れることで、次のステートを作り出す。
以下のように、Claudeへの処理指示と合わせて単一のプロンプトで指示しても良い
```
- SubAgent に Task として作業内容の厳正なレビューを行わせ,
  その結果をもとに、必要な修正を行え
- 自ら git diff やコミット確認を行なって把握せよ
- 作業完了したら REVIEW_COMPLETED とは発言せず、作業報告を行うこと
- SubAgent のレビューの結果、問題がないと判断されたときのみ、REVIEW_COMPLETED とだけ発言せよ
```

# 技術スタック

## 採用技術
**メインスクリプト**: bash
- `workflow` スクリプトはbashで実装
- インストール不要、シンプルな構成
- 状態管理とスクリプト呼び出しのみに集中

**hooksスクリプト**: bash
- `./hooks/` 配下のスクリプトはbashで実装
- 必要に応じて将来的に他言語対応を検討
- シンプルな構成でメンテナンス性を重視

## 技術的解決策
- **JSON処理**: `jq` を使用（多くのシステムで標準装備）
- **状態フレーズ抽出**: `grep`, `tail` などの標準コマンド
- **一時ファイル**: `mktemp` でプロセス安全なファイル名生成
- **スクリプト呼び出し**: 実行権限チェック後に直接実行

## インターフェース設計
```bash
# hooks スクリプトの引数:
# $1: work_summary_file_path (作業報告ファイルのパス)

# hooks スクリプトの出力:
# JSON形式で stdout に出力
# workflow が jq でパース
```

## 設定
- 状態マッピングは `workflow` スクリプト内にハードコード
- 必要に応じて設定ファイル化を検討

## テスト戦略
- hooks の単体テストには bats (bash testing framework) を使用
- モックトランスクリプトファイルを使った統合テスト
- エラーシナリオのテスト含む
